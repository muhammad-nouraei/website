<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Interactive AI Brain Mesh</title>
    <style>
        /* Basic CSS to remove default margin/padding and hide scrollbars */
        body {
            margin: 0;
            overflow: hidden;
            background-color: #000000;
            font-family: 'Inter', sans-serif;
        }
        /* Style for the canvas container */
        #container {
            width: 200px;
            height: 200px;
            display: block;
        }
        /* Info text styling */
        #info {
            position: absolute;
            top: 20px;
            left: 50%;
            transform: translateX(-50%);
            color: rgba(255, 255, 255, 0.8);
            padding: 10px 20px;
            background-color: rgba(0, 0, 0, 0.3);
            border-radius: 20px;
            font-size: 14px;
            text-align: center;
            pointer-events: none; /* Make it non-interactive */
            backdrop-filter: blur(5px);
            -webkit-backdrop-filter: blur(5px);
            border: 1px solid rgba(255, 255, 255, 0.1);
        }
    </style>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500&display=swap" rel="stylesheet">
</head>
<body>

    <div id="container"></div>
    <div id="info">Move your mouse to interact with the neural mesh</div>

    <!-- Import the three.js library from a CDN -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>

    <script>
        // --- SHADERS for custom particle sizes ---

        // Vertex shader: calculates the size of each particle
        const vertexShader = `
            attribute float size;
            void main() {
                vec4 mvPosition = modelViewMatrix * vec4(position, 1.0);
                gl_PointSize = size * (300.0 / -mvPosition.z);
                gl_Position = projectionMatrix * mvPosition;
            }
        `;

        // Fragment shader: sets the color of each particle
        const fragmentShader = `
            void main() {
                if (length(gl_PointCoord - vec2(0.5, 0.5)) > 0.475) discard;
                gl_FragColor = vec4(1.0, 1.0, 1.0, 1.0);
            }
        `;


        // --- SCENE SETUP ---
        let scene, camera, renderer, particles, lines, group;

        // Mouse position variables, normalized to a -1 to 1 range
        let mouseX = 0, mouseY = 0;

        // Window dimensions for responsive calculations
        let windowHalfX = window.innerWidth / 2;
        let windowHalfY = window.innerHeight / 2;

        const PARTICLE_COUNT = 200; // Increased number of nodes for a denser mesh
        const MAX_CONNECTION_DISTANCE = 120; // The maximum distance to draw a line between two nodes

        // An array to store our particle data (position, velocity)
        const particleData = [];

        // Main initialization function
        function init() {
            const container = document.getElementById('container');

            // Create a new three.js scene
            scene = new THREE.Scene();

            // Create a group to hold all the particles and lines for easy rotation
            group = new THREE.Group();
            scene.add(group);

            // Create a perspective camera
            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 1, 3000);
            camera.position.z = 800;

            // --- CREATE PARTICLES (NODES) with custom shader for variable sizes ---
            const pMaterial = new THREE.ShaderMaterial({
                uniforms: {},
                vertexShader: vertexShader,
                fragmentShader: fragmentShader,
                transparent: true,
                blending: THREE.AdditiveBlending,
            });

            const geometry = new THREE.BufferGeometry();
            const positions = new Float32Array(PARTICLE_COUNT * 3);
            const sizes = new Float32Array(PARTICLE_COUNT); // Attribute for particle size

            // Create each particle with a random position and velocity
            for (let i = 0; i < PARTICLE_COUNT; i++) {
                const x = Math.random() * 1000 - 500;
                const y = Math.random() * 1000 - 500;
                const z = Math.random() * 1000 - 500;

                positions[i * 3] = x;
                positions[i * 3 + 1] = y;
                positions[i * 3 + 2] = z;

                sizes[i] = 3; // Initial base size

                // Store particle data for animation
                particleData.push({
                    velocity: new THREE.Vector3(-1 + Math.random() * 2, -1 + Math.random() * 2, -1 + Math.random() * 2).multiplyScalar(0.5),
                    numConnections: 0
                });
            }
            geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
            geometry.setAttribute('size', new THREE.BufferAttribute(sizes, 1));

            particles = new THREE.Points(geometry, pMaterial);
            group.add(particles);

            // --- CREATE LINES (CONNECTIONS) with variable opacity ---
            const lineMaterial = new THREE.LineBasicMaterial({
                vertexColors: true, // Use vertex colors for opacity
                blending: THREE.AdditiveBlending,
                transparent: true
            });

            const lineGeometry = new THREE.BufferGeometry();
            // We create a buffer that can hold the maximum possible number of lines
            const linePositions = new Float32Array(PARTICLE_COUNT * PARTICLE_COUNT * 3);
            const lineColors = new Float32Array(PARTICLE_COUNT * PARTICLE_COUNT * 3);
            lineGeometry.setAttribute('position', new THREE.BufferAttribute(linePositions, 3));
            lineGeometry.setAttribute('color', new THREE.BufferAttribute(lineColors, 3));
            
            lines = new THREE.LineSegments(lineGeometry, lineMaterial);
            group.add(lines);

            // --- RENDERER SETUP ---
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setPixelRatio(window.devicePixelRatio);
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.outputEncoding = THREE.sRGBEncoding;
            container.appendChild(renderer.domElement);

            // --- EVENT LISTENERS ---
            document.addEventListener('mousemove', onDocumentMouseMove, false);
            window.addEventListener('resize', onWindowResize, false);
        }

        // --- EVENT HANDLERS ---
        function onDocumentMouseMove(event) {
            mouseX = event.clientX - windowHalfX;
            mouseY = event.clientY - windowHalfY;
        }

        function onWindowResize() {
            windowHalfX = window.innerWidth / 2;
            windowHalfY = window.innerHeight / 2;
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        // --- ANIMATION LOOP ---
        function animate() {
            requestAnimationFrame(animate);

            let vertexpos = 0;
            let colorpos = 0;
            let numConnected = 0;

            // Reset connection count for each particle
            for (let i = 0; i < PARTICLE_COUNT; i++)
                particleData[i].numConnections = 0;

            const positions = particles.geometry.attributes.position.array;
            const sizes = particles.geometry.attributes.size.array;
            const linePositions = lines.geometry.attributes.position.array;
            const lineColors = lines.geometry.attributes.color.array;

            // Check for connections between particles
            for (let i = 0; i < PARTICLE_COUNT; i++) {
                for (let j = i + 1; j < PARTICLE_COUNT; j++) {
                    const dx = positions[i * 3] - positions[j * 3];
                    const dy = positions[i * 3 + 1] - positions[j * 3 + 1];
                    const dz = positions[i * 3 + 2] - positions[j * 3 + 2];
                    const dist = Math.sqrt(dx * dx + dy * dy + dz * dz);

                    // If the distance is within the threshold, draw a line
                    if (dist < MAX_CONNECTION_DISTANCE) {
                        particleData[i].numConnections++;
                        particleData[j].numConnections++;
                        
                        // Set opacity based on distance (closer = more opaque)
                        const alpha = 1.0 - dist / MAX_CONNECTION_DISTANCE;

                        // Add line vertices
                        linePositions[vertexpos++] = positions[i * 3];
                        linePositions[vertexpos++] = positions[i * 3 + 1];
                        linePositions[vertexpos++] = positions[i * 3 + 2];
                        linePositions[vertexpos++] = positions[j * 3];
                        linePositions[vertexpos++] = positions[j * 3 + 1];
                        linePositions[vertexpos++] = positions[j * 3 + 2];
                        
                        // Add line colors (white with calculated alpha)
                        lineColors[colorpos++] = alpha;
                        lineColors[colorpos++] = alpha;
                        lineColors[colorpos++] = alpha;
                        lineColors[colorpos++] = alpha;
                        lineColors[colorpos++] = alpha;
                        lineColors[colorpos++] = alpha;

                        numConnected++;
                    }
                }
            }

            lines.geometry.setDrawRange(0, numConnected * 2);
            lines.geometry.attributes.position.needsUpdate = true;
            lines.geometry.attributes.color.needsUpdate = true;

            // Animate the particles
            for (let i = 0; i < PARTICLE_COUNT; i++) {
                const particle = particleData[i];
                
                // Update particle size based on number of connections
                sizes[i] = 3 + particle.numConnections * 0.5;

                // Update position with velocity
                positions[i * 3] += particle.velocity.x;
                positions[i * 3 + 1] += particle.velocity.y;
                positions[i * 3 + 2] += particle.velocity.z;

                // Create a bounding box to keep particles contained
                const boundingBoxSize = 500;
                if (positions[i * 3 + 1] < -boundingBoxSize || positions[i * 3 + 1] > boundingBoxSize) particle.velocity.y *= -1;
                if (positions[i * 3] < -boundingBoxSize || positions[i * 3] > boundingBoxSize) particle.velocity.x *= -1;
                if (positions[i * 3 + 2] < -boundingBoxSize || positions[i * 3 + 2] > boundingBoxSize) particle.velocity.z *= -1;
            }
            particles.geometry.attributes.position.needsUpdate = true;
            particles.geometry.attributes.size.needsUpdate = true;

            // Rotate the entire group based on mouse position for an interactive feel
            group.rotation.y += (mouseX / windowHalfX) * 0.0015;
            group.rotation.x += (mouseY / windowHalfY) * 0.0015;

            // Add a slow, constant rotation for ambient movement
            group.rotation.z += 0.0001;

            // Render the scene
            renderer.render(scene, camera);
        }

        // --- START THE EXPERIENCE ---
        init();
        animate();
    </script>
</body>
</html>
